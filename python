range() - массив объектов от 1 до N - 1

print(printMax.__doc__) - Выводит документацию о объекте

__version__ - Позволяет указать версию модуля, а так-же получить информацию о версии импортируемого модуля

del() - удаление объекта

dir() - возвращает список имён, определяемых объектом

type(object) - возвращает тип объекта

isinstance(var, int | float) - воз-ет бул. знач. если первый аргумент является объектом типа, указанного вторым аргументом

enumerate(sequence) - итератор, воз-ет значение каждого элемента и его индекса последовательности имеющей индекс

random.randint(start, end) - возвращает случайное целое число в диапазоне 





Строки(text = type(string):

	text.startswith('') - возвращает тру, если name начинается с той строки, которую передали как аргумент

	text.(r)find('str') - ищет подстроку в строке текст, если не находит воз-ет -1

	text.join(list) - добавляе строку text между каждым элементом списка list, объеденяя лист в строку
	
	text.replace(' ', '', 1) - заменяет в строке kos первый аргумент метода(строка) на второй аргумент метода(строка),
	где третий аргумент метода - это число указывает кол-во замен от первого найденного 

	text.count(' ') - считает кол-во вхождений подстроки в строку текст

	text.(r)partition(' ') - находит первое вхождение подстроки и разбивает строку по принципу первая часть, вторая часть
	(сам разделитель), третья часть, инвертирует в список

	list = text.split(' ', 1) - рзделяет строку на объекты, в качесте разделителя по умал. является пробел,
 	аргумент является резделителем, в качестве второго агрумента идет кол-во итераций разделения
	
	text = f'My name is {переменная}' - быстрый способ редактирования

	text = 'My name is {}'.format(переменная) - формат редактирования строки

	if 'a' in text: - если строка 'a' является частью строки text, то вернет тру

	Регистры:

		Проверка на регистры:

			text.islower() - проверяет, явл. ли буквы в строке маленькими

			text.isupper() - проверяет, явл. ли буквы в строке заглавными

			text.istitle() - проверяет, начинаются ли слова в строке с заглавной буквы



		Работа с регистрами:

			text.upper() - преобразование строки к верхнему регистру

			text.lower() - преобразование строки к нижнему регистру
			
			text.capitalize() - переводит первый символ строки в верхний регистр, а все остальные в ниж.

			text.swapcase() - переводит символы нижнего рег. в верхний и наоборот

			text.title() - первую букву каждого слова переводит в верх. рег., а остальный в ниж. рег.



	Методы обработки строки:

		text.expandtabs([tabsize]) - воз-вр копию строки, в которой все символы табуляции зам. одним или неск. пробелами
			в зависимости от тек. столбца. tabsize по умал. = 8 пробелам
			
		text.lstrip([chars]) - удаление пробельных символов в начале строки

		text.rstrip([chars]) - удаление пробельных символов в конце строки

		text.strip([chars]) - удаление пробельных символов в начале и в конце строки

		text.removeprefix(prefix) - удаляет шаблон с начала строки 

		text.removesuffix(suffix) - удаляет шаблон с начала строки



	Методы проверки на содержимое(возвр-ет булево значение):
		
		kos.isalpha(self) - возвращает тру, если строка состоит только из букв, если строка содержит
		табуляции и прочее - возвращает фолс

		kos.isdigit(self) - возвр-ет тру, если строка сост. только и цифр

		kos.isascii() - возвр-ет тру, если строка состоит только из символов аски
		
		kos.isalnum() - возвр-ет тру, если строка состоит только из букв и или цифр, т.е вернёт тру если строка состоит 
		только из букв, только из цифр, или из букв и цифр, а в остальном вернёт фолс

		kos.isspace() - возвр-ет тру, если строка состоит только из пробельных неотображаемых символов(пробелы, табуляции) 

		kos.isprintable() - возвр-ет тру, если все символы строки можно напечатать

		kos.isidentifier() - возвр-ет тру, если строка может испол-тся как имя переменной 





Числа: 

	isinstance(object, int | str) - воз-ет булево знач., если объект явл. типом, указанным вторым аргументом, вернет тру
	
	all(list) - воз-ет тру, если каждый элемент последовательности, приведенный к булиан явл. тру
	
	any(list) - воз-ет тру, если хотя бы один элемент последовательности, приведённый к бул явл. тру

	max() - воз-ет максимальное число

	digit.round() - привидение к опр значению после запятой

	round(float, 3) - округляет дробное число до степени, указанной как второй аргумент



	Побитовые операции:
	
		bin(int) - вернёт двоичное представление числа



	Бинарные операторы:
		
		& - Бинарный "И" - Копирует бит в результат, если бит есть в обоих операндах 
		
		| - Бинарный "ИЛИ" - Копирует бит, если бит присуствует хотя бы в одном операнде
		
		^ - Бинарный "Исключительное ИЛИ" - копирует бит, если бит присуствует в одном из операндов, но не в обоих сразу
		
		~ - Бинарный комплиментарный оператор - явл. унарным, меняет биты на обратные
		
		<< - Побитовый сдвиг влево - значение левого операнда сдвигается влево на кол-во бит указанного в правом операнде 
		
		>> - Побитовый сдвиг вправо





Списки:

	len() - возвращает количество объектов в списке(указанного как аргумент)
	
	append() - добавляет объект в список с конца

	mylist.sort() - сортирует список по алфавиту(не имеет аргументов)
	
	mylist.pop(1) - вырезает элемент [1] в списке
	
	mylist.remove(1) - удаляет первое вхождение числа 1 в списке
	
	mylist.insert(1, 'hello') - добавляет элемент в список, индекс указывается первым агрументом
	
	mylist.extend(mylist2) - распаковывает последовательность, передаваемую как аргумент, в основную последовательность

	mylist.index('hello') - воз-ет индекс первого вхождения элемента в список, если не найдет, бьёт ошибку
	
	mylist.count() - подсчитывает количество вхождения элемента в список
	
	mylist.sort() - метод сортировки списка
	
	sorted(mylist) - воз-ет отсартированный список
	
	mylist.reverse() - меняет список, разварачивая его, как при отрицательном шаге
	
	mylist.clear() - очищает список, делая его пустым
	
	
	


Словари:

	mydict.get('city', 'Minsk') - безопасное обращение к словарю, в случае, если такого ключа нет - воз-ет значение по умалчанию
	
	mydict.setdefault('city', 'Minsk') - безопасное обращение, в случ отсуствия ключа, создаёт этот ключ со значением по умалчанию
	
	mydict.pop(key[,default]) - удаляет ключ и воз-ет значение, если ключа нет, воз-ет дефолт
	
	mydict.popitem() - удаляет и воз-ет парю - ключ, значение
	
	mydict.keys() - воз-ет значение ключей словаря
	
	mydict.values - воз-ет значения элементов словаря
	
	mydict.items() - воз-ет ключ-значение
	
	mydict.update(new_mylist) - обновляет старый словарь за счет нового, если есть одинаовые ключи


	
	
		
import collections:
	
	Counter(sequence) - воз-ет словарь, где ключ - это каждый элемент последовательности, а значение - кол-во каждого вхождения этого элемента в последовательности
	
	deque(sequence) - воз-ет список последоватеьности, однако deque работает немного быстрее в плане добавления элементов в него
		
		Имеет методы списка, а так-же:
			
			appendleft(element) - добавляет элеиент а начало списка
	
	defaultdict(list) - ничем не отличается от обычного словаря за исключением того, что можно выставить значение по умолчанию, и не будет ошибки при попытке обратитьсяя к несуществующему ключу
	
	orderdict(sequence) - похожий на словарь объект, но он помнит порядок, в котором ему были даны ключи
		
		Имеет методы словаря, а так-же:
			
			popitem(last=True) - удаляет последний элемент если last=True, и первый, если last=False
			move_to_end(key, last=True) - добавляет ключ в конец если last=True, и в начало, если наоборот


		

		
try | except:
		
	try: - блок кода, в который мы помещаем часть своего кода, в котором может быть ошибка
	
	except: - обязательная инструкция try:, отлавливает ошибки в блоке try, выполняет инструкции при выпадении ошибки
	так-же можно указать конкретную ошибку
	
	else: - выполнится только в том случае, если ошибок не вылеало
	
	finally: - блок кода, который выполнится в любом случае
	
	raise: - инсрукция для вызова ошибки самостоятельно
				




Работа с файлами:

	Синтаксис открытия файла file = open('file.txt', 'r', encoding='utf-8')  # Присваеваем переменной file значение объекта открытого файла и работаем с ней (file 
	содержит в себе ссылку на открываемый объект)

	Или with open('file.txt', 'r', encoding='utf-8') as file:  # Это называется контекстный менеджер, делаем все то-же, но открываем новый блок, где и работаем 
		pass													 с файлом, после его завершения файл будет закрыт

	Так-же нам доступен способ открытия нескольких файлов через один контекстный менеджер(начиная с python 3.10), выглядит след. образом:

		with (
			open('input.txt', 'r', encoding='utf-8') as input_file,
			open('output.txt', 'w', encoding='utf-8') as output_file
			):

		до 3.10:

			with open('input.txt', 'r', encoding='utf-8') as input_file, open('output.txt', 'w', encoding='utf-8') as output_file:

	Где первый аргумент функции open - путь до файла(лучше указывать абсолютный)(этот аргумент явд единственным обязательным), второй аргумент - это режим открытия
	(чтение, запись), так-же необязательный аргумент encoding= - отвечает за кодирование файла в поределенной системе, такой как utf-8 например

	У объекта file есть указатель и при полном его прочтении указатель будет находиться в самом конце, что означает, при повторном прочтении, мы получим пустую строку,
	чтобы вернуть указатель в начало, сущ. метод file.seek(0) - который принимает число, которое означает кол-во байт, от начала файла, т.е установивши на ноль, указатель
	будет установлен в самое начало, указав 1 будет установлен на элемент, наход на элементе 1 байта от начала



	Создаём абсолютный путь с помощю модуля pathlib и функции Path:

		from pathlib import Path

		BASE_DIR = Path(__file__).resolve().parent - где фун-ия Path воз-ет строку, явл полным путем до исп. файла. Метод resolve() - разрешает символически ссылки,
		а объект .parent - отсекает последний элемент пути(Например без parent путь выглядит так: /home/kostya/PycharmProjects/pythonProject/venv/main.py), a c ним
		(/home/kostya/PycharmProjects/pythonProject/venv)

		FILE_PATH = (BASE_DIR / 'name_file.txt') - где BASE_DIR - путь до дериктории с исп. файлом и открываемым файлом, а 'name_file.txt' - имя открываемого файла



	Режимы работы с файлом:

		'r' - только чтение
		'w' - только запись. Создаёт новый файл при его отсутствии
		'rb' - чтение бинарных файлов
		'rb+' - чтение и запись бинарных файлов
		'w+' - чтение и запись. Создаёт новый файл, при его отсутствии
		'wb+' - чтение и запись бинарных файлов. Создаёт новый файл, при его отсутствии
		'a' - дозапись. Создаёт новый файл, при его отсутствии
		'a+' - дозапись и чтение. Создаёт новый файл, при его отсутствии
		'ab' - дозапись бинарных. Создаёт новый файл, при его отсутствии
		'ab+' - дозапись и чтение бинарных. Создаёт новый файл, при его отсутствии
		'r+' - чтение и запись
		'wb' - запись бинарных. Создаёт новый файл, при его отсутствии
		'x' - создаёт новый файл, если он уже есть, бъёт ошибку



	files.txt:

		Чтение:

			file.read() - считывает все данные с файла и воз-ет одну текстовую переменную, со значением текса в файле

			file.readline() - этот метод воз-ет итератор(генератор), т.е каждый вызов этого метода воз-ет по одной строке

			file.readlines() - воз-ет список строк, можно представить в виде: lines = [line for line in file]


		Запись:

			file.write(text) - записывает аргумент(str) метода в файл, открытый на запись/дозапись, записывает в одну строку

			file.writelines(list) - принимает список строк, и записывает в файл


	
	files.json:

		В json файлах ключами могут выступать только строки. Строго двойные кавычки. None = null. True = true. По умолчанию json файл
		хранит информацию в ASCII

		Стандартная библиотека, импортируется след. образом: from json import load, loads, dump, dumps:

			load и dump - нужны для десирилизации

			loads и dumps - для серелизации

			Серилизация - превращение объекта в поток байтов, берем словарь и превращаем в наш файл, десирилизация - обратный процесс

			loads и dumps - то-же самое, но при работе со строкой, в которой наход. наш словарь

			После открытия файла на чтение, мы можем десирилизовать json файл функцией load:

				data = load(file)

			После открытия файла на запись, мы можем сирилизовать file функцией dump:

				dump(dict, file) - принимает два обязательных аргумента, где первый - это словарь, второй - сам файл. Если в ключе или значении
				будут русские буквы - она сирилизует их как байты, т.к файл json харанит информацию в ASCII. Чтобы сирилизовать русские буквы как
				символы, мы можем передать необязательный аргумент ensure_ascii со значением False(ensure_ascii=False).	Сам словарь она запишет в 
				json файл в одну строку. Для придания читабельности, файлу json мы можем передать необязательный аргумент indent равный 2(indent=2)


			На реальных проектах используется библиотека ujson(не встроенная). Она написанна на С - поэтому считается самой быстрой. Синтаксис между
			json и ujson - эденитичен. Часто можно встретить подобную запись:

				try:
					from ujson import load, loads, dump, dumps
				except ModuleNotFoundError:
					from json import load, loads, dump, dumps

				Тут все понятно!

	Работа с csv:

		Мы можем работать с csv файлами как с обычными текстовым файлом, однако это не совсем удобно, но есть встроенная библиотека csv, со своими 
		методами и классами. Импортируем их:

			from csv import DictReader, DictWriter

		Открывается файл csv как и любой другой:

			with open('file.csv', 'r', encoding='utf-8') as file:

		После чего мы можем создать экземпляр класса DictReader на основании объекта file:

			reader = DictReader(file)

		Теперь наш reader - это объект класса DictReader, и мы можем увидеть содержимое след. образом:

			print(*reader)

			По сути этот объект явл. итератором

		Сам csv имеет следующую структуру:

			name, age, city
			Kostya, 23, Minsk
			Max, 12, Zalupensk

		Объект reader содержит в себе словари, со след. структурой:

			{'name': 'Kostya', 'age': '23', 'city': 'Minsk'}
			{'name': 'Max', 'age': '12', 'city': 'Zalupensk'}

		Важно знать:

			С файлами csv не работет привидение типов, т.е если в csv файле у нас есть целочисленные значения, в словарь попадут эти значения в 
			виде строки!

		Теперь занесем наши значения в csv файл:

			with open('file.csv', 'w', encoding='utf-8') as file:
				writer = DictWriter(file, fieldnames=('name', 'age'))
				writer.writheader()
				#writer.writerow() 
				writer.writerows()


			В класс DictWriter мы передаем не только файл, но и заголовки в виде кортежа строк, т.к мы будем передавать список словарей.
			Метод writheader() необходим для создания заголовков, т.е если мы создаём новый файл, то он обязателен, однако если мы этот 
			файл дозаписываем, то его вызывать не нужно, иначе он дозапишет и их в середине файла. Для записи сущ. два метода - .writerow(), 
			который принимает словарь и .writerows() - который принимает список словарей





Работа с pydantic:

	Для начала нужно усвоить, что работа с pydantic начинается со схем, поэтому импортируем BaseModel из pydantic:

		from pydantic import BaseModel, Field, validator

		Теперь создаём и описываем схему:

			calss User(BaseModel):
				username: str 
				email: str
				phone: int = None

				class Config:
					title = 'Пользователь'
					description = 'Представление пользователя'

				@validator('string')
				def validate_email(cls, value):
					value = value.lower()
					return value

		Создаём схему: 

			calss User(BaseModel):

		Описываем схему: 

			username: str = Field(min_length=4)
			email: str
			phone: int = None


			Аннотация типов обязательна, т.к по аннотации pydantic валидирует данные, и даже если на вход поступил другой тип данных, pydantic попытается
			привести поступивший тип данных к тому, который указан в аннотации, и если не сможет - выведет ошибку. Теперь username и email - являются 
			обязательными ключами, а phone - необязательным, если пользователь его не передал - ошибки не будет, т.к если он не передан - то будет равен
			значению по умолчанию. Так-же часто приходится указывать ограничения. Для этого есть Field, который мы импортируем из pydantic. Field служит
			для более тонкой настройки. Как пример мы передали функции Field необязательный аргумент min_length со значением 4, это значит, что постуая 
			на вход, username будет проверяться не толко на то, что он является строкой, но и что эта строка будет не меньше 4ёх элементов. 

			Теперь создадим экземпляр класса User и передадим ему словарь, который мы хотим провалидировать:

				dct = {
    				'name': 'kostya',
    				'email': 'gos@mail.com'
				}

				user = User(**dct)

			Тут ошибки не будет, и теперь мы можем вызывать атрибуты класса, например:

				user.email

			Так-же мы можем собрать экземляр класса обратно в словарь:

				var = user.dict()

			Так-же мы можем просмотреть документацию:

				user.schema()

			Так-же мы можем прописать class Config: в котором можем настраивать документацию, например:

				class Config:
					title = 'Пользователь'
					description = 'Представление пользователя'

				Все это будет отображаться в документации, при вызове user.schema()

			И это не все! Мы можем пописать свой кастомный валидатор. Для этого из pydantic мы ипортируем декоратор validator:

				@validator('string')
				def validate_email(cls, value):
					value = value.lower()
					return value

				Имеет один обязательный аргумент, а именно имя поля, которое он будет валидировать. Есть необязательный аргумент pre, 
				который по умолчанию установлен на False, а значит если инвентировать его, то порядок валидации изменится следующим 
				образом - сначала будет срабатывать наш валидатор, только потом - схема. Валидатор обязательно должен принимать ссылку
				на класс, и какой-то объек с которым будет работать. Так-жк он обязательно должен что-то возвращать.





Работа с СУБД:
	


