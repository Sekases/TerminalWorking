max() - Возвращает максимальное число

range() - массив объектов от 1 до N - 1

print(printMax.__doc__) - Выводит документацию о объекте

__version__ - Позволяет указать версию модуля, а так-же получить информацию о версии импортируемого модуля

del() - удаление объекта

dir() - возвращает список имён, определяемых объектом

kos.round() - привидение к опр значению после запятой

type(object) - возвращает тип объекта

round(float, 3) - округляет дробное число до степени, указанной как второй аргумент

isinstance(var, int | float) - воз-ет бул. знач. если первый аргумент является объектом типа, указанного вторым аргументом

enumerate(sequence) - итератор, воз-ет значение каждого элемента и его индекса последовательности имеющей индекс,

random.randint(start, end) - возвращает случайное целое число в диапазоне 


Списки:

	len() - возвращает количество объектов в списке(указанного как аргумент)
	
	append() - добавляет объект в список с конца

	mylist.sort() - сортирует список по алфавиту(не имеет аргументов)
	
	mylist.pop(1) - вырезает элемент [1] в списке
	
	mylist.remove(1) - удаляет первое вхождение числа 1 в списке
	
	mylist.insert(1, 'hello') - добавляет элемент в список, индекс указывается первым агрументом
	
	mylist.extend(mylist2) - распаковывает последовательность, передаваемую как аргумент, в основную последовательность

	mylist.index('hello') - воз-ет индекс первого вхождения элемента в список, если не найдет, бьёт ошибку
	
	mylist.count() - подсчитывает количество вхождения элемента в список
	
	mylist.sort() - метод сортировки списка
	
	sorted(mylist) - воз-ет отсартированный список
	
	mylist.reverse() - меняет список, разварачивая его, как при отрицательном шаге
	
	mylist.clear() - очищает список, делая его пустым
	
	
	
Словари:

	mydict.get('city', 'Minsk') - безопасное обращение к словарю, в случае, если такого ключа нет - воз-ет значение по умалчанию
	
	mydict.setdefault('city', 'Minsk') - безопасное обращение, в случ отсуствия ключа, создаёт этот ключ со значением по умалчанию
	
	mydict.pop(key[,default]) - удаляет ключ и воз-ет значение, если ключа нет, воз-ет дефолт
	
	mydict.popitem() - удаляет и воз-ет парю - ключ, значение
	
	mydict.keys() - воз-ет значение ключей словаря
	
	mydict.values - воз-ет значения элементов словаря
	
	mydict.items() - воз-ет ключ-значение
	
	mydict.update(new_mylist) - обновляет старый словарь за счет нового, если есть одинаовые ключи
	
	m
 


Строки(text = type(string):

	text.startswith('') - возвращает тру, если name начинается с той строки, которую передали как аргумент

	text.(r)find('str') - ищет подстроку в строке текст, если не находит воз-ет -1

	text.join(list) - добавляе строку text между каждым элементом списка list, объеденяя лист в строку
	
	text.replace(' ', '', 1) - заменяет в строке kos первый аргумент метода(строка) на второй аргумент метода(строка),
	где третий аргумент метода - это число указывает кол-во замен от первого найденного 

	text.count(' ') - считает кол-во вхождений подстроки в строку текст

	text.(r)partition(' ') - находит первое вхождение подстроки и разбивает строку по принципу первая часть, вторая часть
	(сам разделитель), третья часть, инвертирует в список

	list = text.split(' ', 1) - рзделяет строку на объекты, в качесте разделителя по умал. является пробел,
 	аргумент является резделителем, в качестве второго агрумента идет кол-во итераций разделения
	
	text = f'My name is {переменная}' - быстрый способ редактирования

	text = 'My name is {}'.format(переменная) - формат редактирования строки

	if 'a' in text: - если строка 'a' является частью строки text, то вернет тру

	Регистры:

		Проверка на регистры:

			text.islower() - проверяет, явл. ли буквы в строке маленькими

			text.isupper() - проверяет, явл. ли буквы в строке заглавными

			text.istitle() - проверяет, начинаются ли слова в строке с заглавной буквы



		Работа с регистрами:

			text.upper() - преобразование строки к верхнему регистру

			text.lower() - преобразование строки к нижнему регистру
			
			text.capitalize() - переводит первый символ строки в верхний регистр, а все остальные в ниж.

			text.swapcase() - переводит символы нижнего рег. в верхний и наоборот

			text.title() - первую букву каждого слова переводит в верх. рег., а остальный в ниж. рег.



	Методы обработки строки:

			text.expandtabs([tabsize]) - воз-вр копию строки, в которой все символы табуляции зам. одним или неск. пробелами
			в зависимости от тек. столбца. tabsize по умал. = 8 пробелам
			
			text.lstrip([chars]) - удаление пробельных символов в начале строки

			text.rstrip([chars]) - удаление пробельных символов в конце строки

			text.strip([chars]) - удаление пробельных символов в начале и в конце строки

			text.removeprefix(prefix) - удаляет шаблон с начала строки 

			text.removesuffix(suffix) - удаляет шаблон с начала строки






	Методы проверки на содержимое(возвр-ет булево значение):
		
		kos.isalpha(self) - возвращает тру, если строка состоит только из букв, если строка содержит
		табуляции и прочее - возвращает фолс

		kos.isdigit(self) - возвр-ет тру, если строка сост. только и цифр

		kos.isascii() - возвр-ет тру, если строка состоит только из символов аски
		
		kos.isalnum() - возвр-ет тру, если строка состоит только из букв и или цифр, т.е вернёт тру если строка состоит 
		только из букв, только из цифр, или из букв и цифр, а в остальном вернёт фолс

		kos.isspace() - возвр-ет тру, если строка состоит только из пробельных неотображаемых символов(пробелы, табуляции) 

		kos.isprintable() - возвр-ет тру, если все символы строки можно напечатать

		kos.isidentifier() - возвр-ет тру, если строка может испол-тся как имя переменной  



Числа: 

	isinstance(object, int | str) - воз-ет булево знач., если объект явл. типом, указанным вторым аргументом, вернет тру
	
	all(list) - воз-ет тру, если каждый элемент последовательности, приведенный к булиан явл. тру
	
	any(list) - воз-ет тру, если хотя бы один элемент последовательности, приведённый к бул явл. тру
	
	
	
	
	
	Побитовые операции:
	
		bin(int) - вернёт двоичное представление числа
		
		
		
	Бинарные операторы:
		
		& - Бинарный "И" - Копирует бит в результат, если бит есть в обоих операндах 
		
		| - Бинарный "ИЛИ" - Копирует бит, если бит присуствует хотя бы в одном операнде
		
		^ - Бинарный "Исключительное ИЛИ" - копирует бит, если бит присуствует в одном из операндов, но не в обоих сразу
		
		~ - Бинарный комплиментарный оператор - явл. унарным, меняет биты на обратные
		
		<< - Побитовый сдвиг влево - значение левого операнда сдвигается влево на кол-во бит указанного в правом операнде 
		
		>> - Побитовый сдвиг вправо
		
		
import collections:
	
	Counter(sequence) - воз-ет словарь, где ключ - это каждый элемент последовательности, а значение - кол-во каждого вхождения этого элемента в последовательности
	
	deque(sequence) - воз-ет список последоватеьности, однако deque работает немного быстрее в плане добавления элементов в него
		
		Имеет методы списка, а так-же:
			
			appendleft(element) - добавляет элеиент а начало списка
	
	defaultdict(list) - ничем не отличается от обычного словаря за исключением того, что можно выставить значение по умолчанию, и не будет ошибки при попытке обратитьсяя к несуществующему ключу
	
	orderdict(sequence) - похожий на словарь объект, но он помнит порядок, в котором ему были даны ключи
		
		Имеет методы словаря, а так-же:
			
			popitem(last=True) - удаляет последний элемент если last=True, и первый, если last=False
			move_to_end(key, last=True) - добавляет ключ в конец если last=True, и в начало, если наоборот
		
		
		
try | except:
		
	try: - блок кода, в который мы помещаем часть своего кода, в котором может быть ошибка
	
	except: - обязательная инструкция try:, отлавливает ощибки в своём блоке выполняет инструкции при выпадении ошибки
	так-же можно указать конкретную ошибку
	
	else: - выполнится только в том случае, если ошибок не вылеало
	
	finally: - блок кода, который выполнится в любом случае
	
	raise: - инсрукция для вызова ошибки самостоятельно
				


Работа с файлами:


	
	json_files:

		For import standart lib use string: from json import load, loads, dump, dumps:

			load - where load is func, used for take dict from json_file 

			loads - 

			dump - where dump is func, used for give dict to json_file(if want to buti dict in json_file, you need isept atibute indent to 1 or higest)

			dumps - 

бля круто, через гит то





