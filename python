range() - массив объектов от 1 до N - 1

print(printMax.__doc__) - Выводит документацию о объекте

__version__ - Позволяет указать версию модуля, а так-же получить информацию о версии импортируемого модуля

del() - удаление объекта

dir() - возвращает список имён, определяемых объектом

type(object) - возвращает тип объекта

isinstance(var, int | float) - воз-ет бул. знач. если первый аргумент является объектом типа, указанного вторым аргументом

enumerate(sequence) - итератор, воз-ет значение каждого элемента и его индекса последовательности имеющей индекс

random.randint(start, end) - возвращает случайное целое число в диапазоне 





Строки(text = type(string):

	text.startswith('') - возвращает тру, если name начинается с той строки, которую передали как аргумент

	text.(r)find('str') - ищет подстроку в строке текст, если не находит воз-ет -1

	text.join(list) - добавляе строку text между каждым элементом списка list, объеденяя лист в строку
	
	text.replace(' ', '', 1) - заменяет в строке kos первый аргумент метода(строка) на второй аргумент метода(строка),
	где третий аргумент метода - это число указывает кол-во замен от первого найденного 

	text.count(' ') - считает кол-во вхождений подстроки в строку текст

	text.(r)partition(' ') - находит первое вхождение подстроки и разбивает строку по принципу первая часть, вторая часть
	(сам разделитель), третья часть, инвертирует в список

	list = text.split(' ', 1) - рзделяет строку на объекты, в качесте разделителя по умал. является пробел,
 	аргумент является резделителем, в качестве второго агрумента идет кол-во итераций разделения
	
	text = f'My name is {переменная}' - быстрый способ редактирования

	text = 'My name is {}'.format(переменная) - формат редактирования строки

	if 'a' in text: - если строка 'a' является частью строки text, то вернет тру

	Регистры:

		Проверка на регистры:

			text.islower() - проверяет, явл. ли буквы в строке маленькими

			text.isupper() - проверяет, явл. ли буквы в строке заглавными

			text.istitle() - проверяет, начинаются ли слова в строке с заглавной буквы



		Работа с регистрами:

			text.upper() - преобразование строки к верхнему регистру

			text.lower() - преобразование строки к нижнему регистру
			
			text.capitalize() - переводит первый символ строки в верхний регистр, а все остальные в ниж.

			text.swapcase() - переводит символы нижнего рег. в верхний и наоборот

			text.title() - первую букву каждого слова переводит в верх. рег., а остальный в ниж. рег.



	Методы обработки строки:

		text.expandtabs([tabsize]) - воз-вр копию строки, в которой все символы табуляции зам. одним или неск. пробелами
			в зависимости от тек. столбца. tabsize по умал. = 8 пробелам
			
		text.lstrip([chars]) - удаление пробельных символов в начале строки

		text.rstrip([chars]) - удаление пробельных символов в конце строки

		text.strip([chars]) - удаление пробельных символов в начале и в конце строки

		text.removeprefix(prefix) - удаляет шаблон с начала строки 

		text.removesuffix(suffix) - удаляет шаблон с начала строки



	Методы проверки на содержимое(возвр-ет булево значение):
		
		kos.isalpha(self) - возвращает тру, если строка состоит только из букв, если строка содержит
		табуляции и прочее - возвращает фолс

		kos.isdigit(self) - возвр-ет тру, если строка сост. только и цифр

		kos.isascii() - возвр-ет тру, если строка состоит только из символов аски
		
		kos.isalnum() - возвр-ет тру, если строка состоит только из букв и или цифр, т.е вернёт тру если строка состоит 
		только из букв, только из цифр, или из букв и цифр, а в остальном вернёт фолс

		kos.isspace() - возвр-ет тру, если строка состоит только из пробельных неотображаемых символов(пробелы, табуляции) 

		kos.isprintable() - возвр-ет тру, если все символы строки можно напечатать

		kos.isidentifier() - возвр-ет тру, если строка может испол-тся как имя переменной 





Числа: 

	isinstance(object, int | str) - воз-ет булево знач., если объект явл. типом, указанным вторым аргументом, вернет тру
	
	all(list) - воз-ет тру, если каждый элемент последовательности, приведенный к булиан явл. тру
	
	any(list) - воз-ет тру, если хотя бы один элемент последовательности, приведённый к бул явл. тру

	max() - воз-ет максимальное число

	digit.round() - привидение к опр значению после запятой

	round(float, 3) - округляет дробное число до степени, указанной как второй аргумент



	Побитовые операции:
	
		bin(int) - вернёт двоичное представление числа



	Бинарные операторы:
		
		& - Бинарный "И" - Копирует бит в результат, если бит есть в обоих операндах 
		
		| - Бинарный "ИЛИ" - Копирует бит, если бит присуствует хотя бы в одном операнде
		
		^ - Бинарный "Исключительное ИЛИ" - копирует бит, если бит присуствует в одном из операндов, но не в обоих сразу
		
		~ - Бинарный комплиментарный оператор - явл. унарным, меняет биты на обратные
		
		<< - Побитовый сдвиг влево - значение левого операнда сдвигается влево на кол-во бит указанного в правом операнде 
		
		>> - Побитовый сдвиг вправо





Списки:

	len() - возвращает количество объектов в списке(указанного как аргумент)
	
	append() - добавляет объект в список с конца

	mylist.sort() - сортирует список по алфавиту(не имеет аргументов)
	
	mylist.pop(1) - вырезает элемент [1] в списке
	
	mylist.remove(1) - удаляет первое вхождение числа 1 в списке
	
	mylist.insert(1, 'hello') - добавляет элемент в список, индекс указывается первым агрументом
	
	mylist.extend(mylist2) - распаковывает последовательность, передаваемую как аргумент, в основную последовательность

	mylist.index('hello') - воз-ет индекс первого вхождения элемента в список, если не найдет, бьёт ошибку
	
	mylist.count() - подсчитывает количество вхождения элемента в список
	
	mylist.sort() - метод сортировки списка
	
	sorted(mylist) - воз-ет отсартированный список
	
	mylist.reverse() - меняет список, разварачивая его, как при отрицательном шаге
	
	mylist.clear() - очищает список, делая его пустым
	
	
	


Словари:

	mydict.get('city', 'Minsk') - безопасное обращение к словарю, в случае, если такого ключа нет - воз-ет значение по умалчанию
	
	mydict.setdefault('city', 'Minsk') - безопасное обращение, в случ отсуствия ключа, создаёт этот ключ со значением по умалчанию
	
	mydict.pop(key[,default]) - удаляет ключ и воз-ет значение, если ключа нет, воз-ет дефолт
	
	mydict.popitem() - удаляет и воз-ет парю - ключ, значение
	
	mydict.keys() - воз-ет значение ключей словаря
	
	mydict.values - воз-ет значения элементов словаря
	
	mydict.items() - воз-ет ключ-значение
	
	mydict.update(new_mylist) - обновляет старый словарь за счет нового, если есть одинаовые ключи


	
	
		
import collections:
	
	Counter(sequence) - воз-ет словарь, где ключ - это каждый элемент последовательности, а значение - кол-во каждого вхождения этого элемента в последовательности
	
	deque(sequence) - воз-ет список последоватеьности, однако deque работает немного быстрее в плане добавления элементов в него
		
		Имеет методы списка, а так-же:
			
			appendleft(element) - добавляет элеиент а начало списка
	
	defaultdict(list) - ничем не отличается от обычного словаря за исключением того, что можно выставить значение по умолчанию, и не будет ошибки при попытке обратитьсяя к несуществующему ключу
	
	orderdict(sequence) - похожий на словарь объект, но он помнит порядок, в котором ему были даны ключи
		
		Имеет методы словаря, а так-же:
			
			popitem(last=True) - удаляет последний элемент если last=True, и первый, если last=False
			move_to_end(key, last=True) - добавляет ключ в конец если last=True, и в начало, если наоборот


		

		
try | except:
		
	try: - блок кода, в который мы помещаем часть своего кода, в котором может быть ошибка
	
	except: - обязательная инструкция try:, отлавливает ошибки в блоке try, выполняет инструкции при выпадении ошибки
	так-же можно указать конкретную ошибку
	
	else: - выполнится только в том случае, если ошибок не вылеало
	
	finally: - блок кода, который выполнится в любом случае
	
	raise: - инсрукция для вызова ошибки самостоятельно
				




Работа с файлами:

	Синтаксис открытия файла file = open('file.txt', 'r', encoding='utf-8')  # Присваеваем переменной file значение объекта открытого файла и работаем с ней (file 
	содержит в себе ссылку на открываемый объект)

	Или with open('file.txt', 'r', encoding='utf-8') as file:  # Это называется контекстный менеджер, делаем все то-же, но открываем новый блок, где и работаем 
		pass													 с файлом, после его завершения файл будет закрыт

	Так-же нам доступен способ открытия нескольких файлов через один контекстный менеджер(начиная с python 3.10), выглядит след. образом:

		with (
			open('input.txt', 'r', encoding='utf-8') as input_file,
			open('output.txt', 'w', encoding='utf-8') as output_file
			):

		до 3.10:

			with open('input.txt', 'r', encoding='utf-8') as input_file, open('output.txt', 'w', encoding='utf-8') as output_file:

	Где первый аргумент функции open - путь до файла(лучше указывать абсолютный)(этот аргумент явд единственным обязательным), второй аргумент - это режим открытия
	(чтение, запись), так-же необязательный аргумент encoding= - отвечает за кодирование файла в поределенной системе, такой как utf-8 например

	У объекта file есть указатель и при полном его прочтении указатель будет находиться в самом конце, что означает, при повторном прочтении, мы получим пустую строку,
	чтобы вернуть указатель в начало, сущ. метод file.seek(0) - который принимает число, которое означает кол-во байт, от начала файла, т.е установивши на ноль, указатель
	будет установлен в самое начало, указав 1 будет установлен на элемент, наход на элементе 1 байта от начала



	Создаём абсолютный путь с помощю модуля pathlib и функции Path:

		from pathlib import Path

		BASE_DIR = Path(__file__).resolve().parent - где фун-ия Path воз-ет строку, явл полным путем до исп. файла. Метод resolve() - разрешает символически ссылки,
		а объект .parent - отсекает последний элемент пути(Например без parent путь выглядит так: /home/kostya/PycharmProjects/pythonProject/venv/main.py), a c ним
		(/home/kostya/PycharmProjects/pythonProject/venv)

		FILE_PATH = (BASE_DIR / 'name_file.txt') - где BASE_DIR - путь до дериктории с исп. файлом и открываемым файлом, а 'name_file.txt' - имя открываемого файла



	Режимы работы с файлом:

		'r' - только чтение
		'w' - только запись. Создаёт новый файл при его отсутствии
		'rb' - чтение бинарных файлов
		'rb+' - чтение и запись бинарных файлов
		'w+' - чтение и запись. Создаёт новый файл, при его отсутствии
		'wb+' - чтение и запись бинарных файлов. Создаёт новый файл, при его отсутствии
		'a' - дозапись. Создаёт новый файл, при его отсутствии
		'a+' - дозапись и чтение. Создаёт новый файл, при его отсутствии
		'ab' - дозапись бинарных. Создаёт новый файл, при его отсутствии
		'ab+' - дозапись и чтение бинарных. Создаёт новый файл, при его отсутствии
		'r+' - чтение и запись
		'wb' - запись бинарных. Создаёт новый файл, при его отсутствии
		'x' - создаёт новый файл, если он уже есть, бъёт ошибку



	files.txt:

		Чтение:

			file.read() - считывает все данные с файла и воз-ет одну текстовую переменную, со значением текса в файле

			file.readline() - этот метод воз-ет итератор(генератор), т.е каждый вызов этого метода воз-ет по одной строке

			file.readlines() - воз-ет список строк, можно представить в виде: lines = [line for line in file]


		Запись:

			file.write(text) - записывает аргумент(str) метода в файл, открытый на запись/дозапись, записывает в одну строку

			file.writelines(list) - принимает список строк, и записывает в файл


	
	files.json:

		В json файлах ключами могут выступать только строки. Строго двойные кавычки. None = null. True = true. По умолчанию json файл
		хранит информацию в ASCII

		Стандартная библиотека, импортируется след. образом: from json import load, loads, dump, dumps:

			load и dump - нужны для десирилизации

			loads и dumps - для серелизации

			Серилизация - превращение объекта в поток байтов, берем словарь и превращаем в наш файл, десирилизация - обратный процесс

			loads и dumps - то-же самое, но при работе со строкой, в которой наход. наш словарь

			После открытия файла на чтение, мы можем десирилизовать json файл функцией load:

				data = load(file)

			После открытия файла на запись, мы можем сирилизовать file функцией dump:

				dump(dict, file) - принимает два обязательных аргумента, где первый - это словарь, второй - сам файл. Если в ключе или значении
				будут русские буквы - она сирилизует их как байты, т.к файл json харанит информацию в ASCII. Чтобы сирилизовать русские буквы как
				символы, мы можем передать необязательный аргумент ensure_ascii со значением False(ensure_ascii=False).	Сам словарь она запишет в 
				json файл в одну строку. Для придания читабельности, файлу json мы можем передать необязательный аргумент indent равный 2(indent=2)


			На реальных проектах используется библиотека ujson(не встроенная). Она написанна на С - поэтому считается самой быстрой. Синтаксис между
			json и ujson - эденитичен. Часто можно встретить подобную запись:

				try:
					from ujson import load, loads, dump, dumps
				except ModuleNotFoundError:
					from json import load, loads, dump, dumps

				Тут все понятно!

	Работа с csv:

		Мы можем работать с csv файлами как с обычными текстовым файлом, однако это не совсем удобно, но есть встроенная библиотека csv, со своими 
		методами и классами. Импортируем их:

			from csv import DictReader, DictWriter

		Открывается файл csv как и любой другой:

			with open('file.csv', 'r', encoding='utf-8') as file:

		После чего мы можем создать экземпляр класса DictReader на основании объекта file:

			reader = DictReader(file)

		Теперь наш reader - это объект класса DictReader, и мы можем увидеть содержимое след. образом:

			print(*reader)

			По сути этот объект явл. итератором

		Сам csv имеет следующую структуру:

			name, age, city
			Kostya, 23, Minsk
			Max, 12, Zalupensk

		Объект reader содержит в себе словари, со след. структурой:

			{'name': 'Kostya', 'age': '23', 'city': 'Minsk'}
			{'name': 'Max', 'age': '12', 'city': 'Zalupensk'}

		Важно знать:

			С файлами csv не работет привидение типов, т.е если в csv файле у нас есть целочисленные значения, в словарь попадут эти значения в 
			виде строки!

		Теперь занесем наши значения в csv файл:

			with open('file.csv', 'w', encoding='utf-8') as file:
				writer = DictWriter(file, fieldnames=('name', 'age'))
				writer.writheader()
				#writer.writerow() 
				writer.writerows()


			В класс DictWriter мы передаем не только файл, но и заголовки в виде кортежа строк, т.к мы будем передавать список словарей.
			Метод writheader() необходим для создания заголовков, т.е если мы создаём новый файл, то он обязателен, однако если мы этот 
			файл дозаписываем, то его вызывать не нужно, иначе он дозапишет и их в середине файла. Для записи сущ. два метода - .writerow(), 
			который принимает словарь и .writerows() - который принимает список словарей





Работа с pydantic:

	Для начала нужно усвоить, что работа с pydantic начинается со схем, поэтому импортируем BaseModel из pydantic:

		from pydantic import BaseModel, Field, validator

		Теперь создаём и описываем схему:

			calss User(BaseModel):
				username: str 
				email: str
				phone: int = None

				class Config:
					title = 'Пользователь'
					description = 'Представление пользователя'

				@validator('string')
				def validate_email(cls, value):
					value = value.lower()
					return value

		Создаём схему: 

			calss User(BaseModel):

		Описываем схему: 

			username: str = Field(min_length=4)
			email: str
			phone: int = None


			Аннотация типов обязательна, т.к по аннотации pydantic валидирует данные, и даже если на вход поступил другой тип данных, pydantic попытается
			привести поступивший тип данных к тому, который указан в аннотации, и если не сможет - выведет ошибку. Теперь username и email - являются 
			обязательными ключами, а phone - необязательным, если пользователь его не передал - ошибки не будет, т.к если он не передан - то будет равен
			значению по умолчанию. Так-же часто приходится указывать ограничения. Для этого есть Field, который мы импортируем из pydantic. Field служит
			для более тонкой настройки. Как пример мы передали функции Field необязательный аргумент min_length со значением 4, это значит, что постуая 
			на вход, username будет проверяться не толко на то, что он является строкой, но и что эта строка будет не меньше 4ёх элементов. 

			Теперь создадим экземпляр класса User и передадим ему словарь, который мы хотим провалидировать:

				dct = {
    				'name': 'kostya',
    				'email': 'gos@mail.com'
				}

				user = User(**dct)

			Тут ошибки не будет, и теперь мы можем вызывать атрибуты класса, например:

				user.email

			Так-же мы можем собрать экземляр класса обратно в словарь:

				var = user.dict()

			Так-же мы можем просмотреть документацию:

				user.schema()

			Так-же мы можем прописать class Config: в котором можем настраивать документацию, например:

				class Config:
					title = 'Пользователь'
					description = 'Представление пользователя'

				Все это будет отображаться в документации, при вызове user.schema()

			И это не все! Мы можем пописать свой кастомный валидатор. Для этого из pydantic мы ипортируем декоратор validator:

				@validator('string')
				def validate_email(cls, value):
					value = value.lower()
					return value

				Имеет один обязательный аргумент, а именно имя поля, которое он будет валидировать. Есть необязательный аргумент pre, 
				который по умолчанию установлен на False, а значит если инвентировать его, то порядок валидации изменится следующим 
				образом - сначала будет срабатывать наш валидатор, только потом - схема. Валидатор обязательно должен принимать ссылку
				на класс, и какой-то объек с которым будет работать. Так-жк он обязательно должен что-то возвращать.





Работа с СУБД:
	
	Релеционная база данных - это база данных, которая хранит в себе информацию в виде таблиц, которые могут быть связааны между собой.

	Нерелеционная база данных - это база данных, не имеющая какой-либо структуры.

	sqlite3 - это файловая база данных, что значит - она хранит все таблицы в одном файле. Хороша для создания прототипа. Библиотека
	для работы с sqlite3 поставляется вместе с пайтоном.

	Важно помнить, что ID выдаются единожды и при удалении позции с ID - 1, следующая добавленная позиция будет иметь ID - 2.

	Работа с sqlite3: 

		Для начала нужно импортироваь библиотеку, для работы с sqlite3:

			from sqlite3 import connect

			Функция connect необходима для подключения к базе данных.

		Подключаемся к базе данных:

			conn = connect(data_base.sqlite3) 

			Расширение файла базы данных может быть любым, однако для читаемости кода следует придерживаться расширения file.sqlite3
			или file.db

		Мы подключились к базе данных. Если её не было, функция connect автоматически создаст её.

		Теперь нам нужно создать курсор. Курсор служит для управления базы данных, а точнее для совершения запросов. Создаём курсор:

			cur = conn.cursor()

			Метод .cursor() - не принимает аргументов и создает нам курсор для взаимодействия с базой данных.

		Есть несколько разделов языка SQL. Первым мы рассмотрим DDL. DDL - это язык для взаимодействия со структурой баззы даных. 
		DML - data manipulation language - для взаимодействия с информацией.

		В каждой таблице должен присуствовать уникальный ключ - ID, для возможности бытрого поиска объекта в таблице и для возможности
		другой таблицы ссылаться на объект по его ключу. Выдаётся единожды каждой записи. Так-же есть понятие внешнего ключа, это зтот
		атрибут необходим для ссылки на объект другой таблицы при необходимости.

		Связи таблиц:

			Один к одному(1:1) - это когда на одну запись в таблице ссылается только одна запись из друглй таблицы. У одного человека 
			только один паспорт.

			Один ко многим(1:M) - это когда на один элемент таблицы может ссылаться сколь угодно много элементов другой таблицы. У одного
			человека может быть много номеров телефона.

			Многие ко многим(М:М) - как таковой связи многие ко многим не существует, это делается по средствам третьей таблицы. У одного
			человека может быть много адрессов и на одном адрессе может проживать несколько людей.

		Создаём таблицу:

			cur.execute('''
			CREATE TABLE IF NOT EXISTS category(
				id INT PRIMARY KEY AUTOINCREMENT,
				name VARCHAR(32) NOT NULL UNIQUE
			);
			''')
			conn.commit()

			Обращаемся к нашему курсору методом .execute('''ИНСТРУКЦИИ'''), который принимает инструкции языка SQL между шестью ординарными 
			кавычками. В этом блоке мы пишем все необходимые нам инструкции, например создания таблицы - CREATE TABLE, после чего вводим 
			инструкцию на проверку существовании таблицы с этим именем - IF NOT EXISTS. Далее мы задаём имя таблице - category();. Любая 
			инструкция SQL должна заканчиваться точкой с запятой. В скобках, после указания имени таблицы мы должны указать её атрибуты.
			У каждой таблице должен быть уникальный ключ - ID, смотри выше. Так как наш id - это число, соответсвенно указываем тип INT.
			Далее мы указываем параметры этого атрибута - PRIMARY KEY, который означает, что этот атрибут уникален и не пустой. Далее мы 
			указываем, что хотим, чтобы наш ключ выдавался автоматически, без нашего вмешательства - AUTOINCREMENT - что значит, что каждый 
			ключ будет получать значение от 1 и до скончания времён, или таблицы. Инструкция AUTOINCREMENT присуща только sqlite3. Каждая 
			инструкция должна заканчиваться запятой. Далее мы передам аргумент name - который будет представлен в виде текста - VARCHAR(32)
			и именть ограничение по длинне в 32 символа, не пустой - NOT NULL, и является уникальным - UNIQUE. После последней инструкции 
			запятую не ставим! Чтобы изменения вступили в силу нам необходимо отправить наш код в базу данных. Для этого мы обращаемся 
			к нашему conn(connect) методом .commit(), который и записывает все изменнения в саму базу данных.

		Теперь создадим таблицу, элементы которой будут ссылаться на нашу первую таблицу category:

			cur.execute('''
			CREATE TABLE IF NOT EXISTS product(
				id iNTEGER PRIMARY KEY AUTOINCREMENT,
				title VARCHAR(64) NOT NULL UNIQUE,
				description TEXT,
				price DECIMAL(8, 2) NOT NULL DEFAULT(100.0),
				category_id INTEGER NOT NULL,
				FOREIGN KEY (category_id) REFERENCES category(id) 
			);
			''')

			Все то-же самое, только тут мы уже добавляем ссылку на атрибут внешней таблицы. Ключ внешней ссылки должен повторять тип данных
			ключа внешней таблицы, т.е category, в нашем случае это INTEGER - category_id INTEGER. Если к category_id добавить инструкцию 
			UNIQUE - то ээто будет отношение один к одному(1:1). Явное описание всех ссылок происходит только после описания всех атрибутов
			таблицы. Делается это инструкцией FOREIGN KEY, после которого указывается атрибут данной таблицы, который неявно указывает на
			атрибут другой таблицы. После идёт инструкция REFERENCES - которая и говорит нам, что это ссылка, и последним идет название табл.
			на которую мы ссылаемся и её атрибут в скобках.

		Тперь внесем данные в таблицу:

			cur.execute('''
			INSERT INTO category(name) VALUES(?).\;
			''', ('Coffee', ))
			conn.commit()

			Инструкция INSERT INTO позволяет нам добавить элемент в таблицу, имя которой мы указываем после этой инструкции. В имя таблицы мы
			передаём название атрибутов, которые хотим заполнить. След. инструкция VALUES() - принимает значения, которыми мы хотим заполнить
			наши атрибуты, однако, вместо самих значений мы оставляем вопросительные знаки, во избежание SQL-инъекций. Уже вторым аргументом 
			метода .execute(), мы передаём картеж значений, которыми и заполним наш элемент таблицы. После чего закономерно делаем коммит.

			Если же нам нужно создать сразу несколько элементов таблицы, то мы можем воспользоваться методом .executemany(), и передать ему 
			кортеж кортежей.

				cur.executemany('''
				INSERT INTO category(name) VALUES(?).\;
				''', (('Coffee', ), ('Tea', )))
				conn.commit()

			Если же нам нужно обновить данные в таблице, то нам поможет инструкция UPDARE:

				cur.execute('''
				UPDATE category SET name = 	? WHERE id = ?;
				''', ('Кофе', 3))
				conn.commit()

				Если не указать ID - то обновятся все позиции под name

			Хотим что-то удалить, тогда нам нужен DELETE:

				cur.execute('''
				DELETE FROM category WHERE id = ?;
				''')

				Если не указать ID, то удалится все!

			Выборка даных:

				cur.execute('''
				SELECT * FROM product;
				''')

				Где инсрукция SELECT - сама выборка, элемент за ней - это значение атрибута, по которому мы будем получать данные,
				в нашем случае это * - значит все. FROM name_table - это выборка таблицы, из которой будем получать данные. После 
				этой операции все наши данные хранятся в объекте cur. Чтобы их достать есть три метода:

					print(cur.fetchone) - достаёт по одному элементу, как next()
					print(cur.fetchmany(*)) - он уже принимает как аргумент кол-во элем. которых вернёт
					print(cur.fetchall) - вернёт все в виде списка картежей



		Типы данных:

			VARCHAR - строка с ограничением по кол-ву символов.
			DECIMAL - число с плавующей точкой, первый аргумент - кол-во цифр, второй - кол-во цифр после запятой

		Операторы SQL:

			SELECT - выбирает данные, удовлетворяющие заданным условиям
			INSERT - добавляет новые данные
			UPDATE - изменяет сущ. данные
			DELETE - удаляет данные
			WHERE - необходим для фильтрации выборки и удаления
			ORDER BY - для сортировки
			JOIN - v snimkach ecrana





	Работа с postgresql:

		Работа с psycopg2:

			Для начала импортируем библиотеку и откроем соединение:

				from psycopg2 import connect

				conn = connect('postgresql://username:password@host:port/namedb')

				Где - первым указыется имя базы данных, вторым - имя пользователя, затем - пароль пользователя, после чего - через собаку,
				хост, далее - порт и имя базы данных.


			Теперь создадим курсор, который работает только через контекстный менеджер:

				with conn.cursor() sa cur:

				И теперь работаем с сырыми строками:

					cur.execute('''
						CREATE TABLE IF NOT EXISTS category(
							id SERIAL PRIMARY KEY,
							name VARCHAR(32) NOT NULL UNIQUE
						);
					''')
					conn.commit()

					Где SERIAL - это альтернатива AUTOINCREMENT, вместо вопроса при указании значений тут мы ставим %s


		Работа с sqlalchemy:

			Алхимимя работае схожим с pydantic образом. Структура выстраивается через классы, которые называются моделями. Для этого нам нужно
			создать класс схему, наследуясь от деклорационного класса:

				from sqlalchemy.orm import DeclarativeBase, declared__attr, Session
				from sqlalchemy import Column, SMALLINT, VARCHAR, INT, ForeignKey, DECIMAL, update, select, delete

			Теперь создадим наш базовый класс:

				class Base(DeclarativeBase):
					id = Column(INT, primary_key=True)
					
					@declared__attr
					def __tablename__(cls) -> str:
						return ''.join([f'_{i.lower()}' if i.isupper else i for i in cls.__name__]).strip

				class Category(Base):
					#__tablename__ = 'category'			# Вынесли в функцию __tablename__ в Base
					id = Column(SMALLINT, primary_key=True)
					name = Column(VARCHAR(64), unique=True, nullable=False)

				class Product(DeclarativeBase):
					#__tablename__ = 'product'
					№id = Column(INT, primary_key=True)			# Вынесли в класс Base
					title = Column(VARCHAR(64), nullable=False)
					description = Column(VARCHAR(2048), )
					price = Column(DECIMAL(8, 2), nullable=False, default=100)
					category_id = Column(SMALLINT, ForeignKey(Category.id, ondelete='CASCADE'), nullable=False)

					Даже если поставить зашлушку, то этот класс уже можно использовать как модель. Каждый класс отвечает за отдельную таблицу 
					в бд. Создадим такой класс, но для начала нам нужны некоторые типы данных, которые мы будем импортировать из библитеки
					следующим образом: form sqlalchemy import Column, SMALLINT, VARCHAR - где Colum - это функция для заполнения колонки таблицы.
					Теперь начинаем заполнять таблицу колонкой id: id = Column(SMALLINT, primary_key=True) - где первый аргумент - тип данных, а 
					второй - означает что элемент уникальный, не пустой, с автоинкрементом. nullable=False - значит не пустой. Импортируем так-же
					ForeignKey из sqlalchemy для ссылок на другие таблицы. Пропишем ещё класс Product, элементы которого буду ссылаться на нашу 
					первыю таблицу.  Так-же у каждого класса есть атрибут __tablename__, который будет явл. строкой, обозначающей название вашей
					таблицы в базе данных. default - выдаёт значение по умолчанию. Теперь внешний ключ. Делаем это как и раньше: category_id =
					Column(SMALLINT, ForeignKey(Category.id, ondelete='CASCADE'), nullable=False) - где первый аргумент - это тип данных, который 
					должен совпадать с типом данных, колонки, на которую ссылается таблица. Каскадный тип удаления. Так же мы можем оптимизировать
					некоторые моменты. Например почти у всех наших классов id - одинаков, поэтому мы можем вынести его в класс Base и наследуясь, 
					все остальные классы будут наследовать и атрибут id. Сейчас нам понадобится declared__attr из sqlalchemy.orm. В класс Base 
					вешаем декоратор @declared__attr, после чего объявляем метод с именем атрибута и прописываем его так, чтобы он получал имя 
					класса в виде строки и обрабатывад его таким образом, чтобы получилась строка с именем класса. Теперь в каждом классе атрибут 
					__tablename__ будет генерироваться автоматически.

			Теперь переносим в бд:

				Нам необходимо создать эти таблички в бд. Делать мы это будем серез алембик. Нам необходимо проинициализировать алембик. Это делается
				в каждом проекте единожды. В папке с проектом необходимо выполнить команду: alembic init alembic. Пока в нем нас интересует только
				одна строка на позиции 63 - sqlalchemy.url - которая отвечает за подключение алхимии к бд. Выглядит всё это примерно след. образом - 
				posgresql://kostya:kostya@localhost:5432/belhard - где первый аргумент - это название базы данных, второй - имя пользователя, третий -
				пароль пользователя, третий - хост, четвёртый - хост, пятый - имя базы данных. Так же нам нужно изменить файл env.py для настройки
				автогенерации миграции. Импортируем нашу базовую модель из файла, где она описана, в файл env.py. В моём случае - from main import Base.
				Затем переходим на строку 22, где прописана строка target_metadata = None, и нам необходимо изменить её на(в моём случае) target_metadata =
				Base.metadata. теперь нам нужно научиться генерировать файл миграции. С самого начала нам нужно проверить версию нашей базы данных, т.к
				если мы не будем находиться на свежей версии дб, то файлы миграции старых версий придеться удалять руками. Создаём файл миграции, в терминале
				прописываем - alembic revision --autogenerate. Мы сгенерировали файл миграции и в дб у нас появилась таблица с названием alembic_version.
				Теперь нам нужно применить эту миграцию, возв. в терминал. Пишем - alembic upgrade head, мы можем обновить бд за счет файла миграции след. 
				образом - либо по номеру ревизии, который указан в файле ревизии и имени файла ревизии, либо на самую свежую ревизию, обратиться к ней можно 
				по имени head. После этого действия в нашей базе данных будут размещенны таблицы. 

			Запросы в бд по средствам алхимии:

				Для этого нам нужнры две сущности, одна для подключения, другая для запросов. Нам нужно заимпортировать сущность create_engine из модуля
				sqlalchemy. Для создания сессии лучше всего исп. функцию session_maker, которая импортируется из sqlalchemy.orm. Как правило базовая модель описывается 
				в другом модуле, относительно кода, и create_engine описывается там, где и базовая модель. Мы же будем описывать внутри базового класса в качестве 
				атрибутов класса. Теперь внутри базовой модели описываем engine:

					class Base(DeclarativeBase):
						id = Column(INT, primary_key=True)

						engine = create_engine('postgresql://user_name:password@localhost:5432/name_db')
						session = sessionmaker(bing=engine)

						@declared__attr
						def __tablename__(cls):
							pass

					Где engine - равна функции создания сессии с сылкой на бд. Это аналог connect. Далее мы открываем сессию - session, которой будет передан
					аргумент bing, который в свою очередь будет равен подключении сесии engine.

				Теперь с помощью контекстного менеджера мы откроем сессию:

					with Base.session() as session:  # type Session
						categories = [
							Category(name='Coffee'),
							Category(name='Tea')
						]
						session.add_all(categories)
						session.commit
						for category in catigories:
							session.refresh(category)

					Теперь будем заполнять таблицы. Так как в табл. катигрория у нас только одна колонка(id заполняются автоматом), то и в качестве аргумента
					мы будем передавать только name. Теперь нам нужно добавить изменения в бд. У функции session есть два метода - session.add и session.add_all.
					Метод add применяется когда мы записываем один объект, а add_all применяется когда нам нужно записать несколько объектов и на вход этого 
					метода мы передаём список объектов. На данном этапе мы только добавили сущности к сессии. Поэтому слеед. этапом вызываем commit у сущности 
					session - session.commit(). Так-же для того, чтобы у каждого элемента сущности появился id нам необходимо зарефрешить эти элементы методом 
					refresh. 

				Переходим к update:

					Для начала нам необходимо импортировать сущность update из sqlalchemy. 

						with Base.session() as session:  # type Session
							session.execute(
								update(Category).values(name='Cofe').filter(Category.id == 1)
							)
							session.commit()

						Где в session.execute() мы передаём функцию, название которой определяет её задачу, например update(), куда мы передаём таблицу, и в 
						метод .values() мы передаём изменённое значение. Так-же нам необходимо отфильтровать элементы таблицы, у которых будем изменять значение.





